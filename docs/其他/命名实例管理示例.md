# 命名实例管理 - 具体实现示例

*文档创建：2025年9月30日*

## 🎯 核心思路：通过名字管理不同实例

### 基本概念
每个`LlmConnectorProvider`都有一个`name`属性，用来标识这个实例的用途。组件通过`useLlmConnector()`可以获取到当前实例的名字和对应的client。

## 🛠️ 实现方案

### 第一步：扩展 LlmConnectorProvider

```tsx
// src/providers/LlmConnectorProvider.tsx
export const LlmConnectorProvider: React.FC<{
  children: ReactNode;
  name?: string;        // 🆕 实例名称
  storageKey?: string;  // 现有：存储键
}> = ({ children, name = 'default', storageKey }) => {
  const logic = useLlmConnectorLogic();
  
  // 在context中添加实例名称
  const contextValue = useMemo(() => ({
    ...logic,
    instanceName: name
  }), [logic, name]);
  
  return (
    <LlmConnectorContext.Provider value={contextValue}>
      {children}
    </LlmConnectorContext.Provider>
  );
};
```

### 第二步：更新 Context 类型

```tsx
// src/contexts/LlmConnectorContext.ts
export type LlmConnectorContextType = ReturnType<typeof useLlmConnectorLogic> & {
  instanceName: string; // 🆕 实例名称
};
```

### 第三步：具体使用示例

```tsx
// App.tsx - 多实例管理
function AIWorkspace() {
  return (
    <div className="ai-workspace">
      {/* 📄 文档总结区域 - 使用便宜的模型 */}
      <LlmConnectorProvider 
        name="document-summary" 
        storageKey="summary-llm-config"
      >
        <section className="summary-area">
          <h2>📄 文档总结助手</h2>
          <p>推荐模型: GPT-4o Mini (经济模式)</p>
          <ConnectionFormZh />
          <DocumentSummary />
        </section>
      </LlmConnectorProvider>

      {/* 💬 智能对话区域 - 使用高质量模型 */}
      <LlmConnectorProvider 
        name="intelligent-chat" 
        storageKey="chat-llm-config"
      >
        <section className="chat-area">
          <h2>💬 智能对话助手</h2>
          <p>推荐模型: Claude-3.5 Sonnet (高质量模式)</p>
          <ConnectionFormZh />
          <IntelligentChat />
        </section>
      </LlmConnectorProvider>

      {/* 🌐 多语言翻译区域 - 使用多语言强的模型 */}
      <LlmConnectorProvider 
        name="multi-translate" 
        storageKey="translate-llm-config"
      >
        <section className="translate-area">
          <h2>🌐 多语言翻译助手</h2>
          <p>推荐模型: Gemini-1.5 Pro (多语言强)</p>
          <ConnectionFormZh />
          <MultiLanguageTranslate />
        </section>
      </LlmConnectorProvider>
    </div>
  );
}

// DocumentSummary.tsx - 总结组件
const DocumentSummary = () => {
  const { llmClient, instanceName, states } = useLlmConnector();
  const [document, setDocument] = useState('');
  const [summary, setSummary] = useState('');
  const [isLoading, setIsLoading] = useState(false);

  const handleSummarize = async () => {
    if (!llmClient) {
      alert(`${instanceName} 实例未连接，请先配置连接`);
      return;
    }

    setIsLoading(true);
    try {
      const result = await llmClient.chat({
        messages: [
          { role: 'system', content: '你是专业的文档总结助手，请提供简洁准确的总结' },
          { role: 'user', content: `请总结以下文档内容：\n\n${document}` }
        ]
      });
      
      setSummary(result.text);
      console.log(`✅ ${instanceName} 总结完成`);
    } catch (error) {
      console.error(`❌ ${instanceName} 总结失败:`, error);
      alert(`${instanceName} 总结失败，请检查配置`);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="document-summary" data-instance={instanceName}>
      {/* 实例状态指示器 */}
      <div className="instance-status">
        <span className="instance-name">实例: {instanceName}</span>
        <span className={`status ${states.status}`}>
          {states.status === 'connected' ? '✅ 已连接' : '❌ 未连接'}
        </span>
        {states.status === 'connected' && (
          <span className="model">模型: {states.model}</span>
        )}
      </div>

      {/* 功能界面 */}
      <div className="summary-interface">
        <textarea
          value={document}
          onChange={(e) => setDocument(e.target.value)}
          placeholder="请输入需要总结的文档内容..."
          rows={8}
          className="document-input"
        />
        
        <button 
          onClick={handleSummarize}
          disabled={!document.trim() || !llmClient || isLoading}
          className="summarize-button"
        >
          {isLoading ? '🤔 总结中...' : '📄 开始总结'}
        </button>

        {summary && (
          <div className="summary-result">
            <h4>📋 总结结果：</h4>
            <div className="summary-content">{summary}</div>
          </div>
        )}
      </div>
    </div>
  );
};

// IntelligentChat.tsx - 对话组件
const IntelligentChat = () => {
  const { llmClient, instanceName, states } = useLlmConnector();
  const [messages, setMessages] = useState<Array<{role: string, content: string}>>([]);
  const [input, setInput] = useState('');
  const [isLoading, setIsLoading] = useState(false);

  const handleSendMessage = async () => {
    if (!llmClient) {
      alert(`${instanceName} 实例未连接，请先配置连接`);
      return;
    }

    const userMessage = { role: 'user', content: input };
    const newMessages = [...messages, userMessage];
    setMessages(newMessages);
    setInput('');
    setIsLoading(true);

    try {
      const result = await llmClient.chat({
        messages: [
          { role: 'system', content: '你是智能对话助手，请提供有帮助的回答' },
          ...newMessages
        ]
      });
      
      setMessages([...newMessages, { role: 'assistant', content: result.text }]);
      console.log(`✅ ${instanceName} 对话响应完成`);
    } catch (error) {
      console.error(`❌ ${instanceName} 对话失败:`, error);
      alert(`${instanceName} 对话失败，请检查配置`);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="intelligent-chat" data-instance={instanceName}>
      {/* 实例状态指示器 */}
      <div className="instance-status">
        <span className="instance-name">实例: {instanceName}</span>
        <span className={`status ${states.status}`}>
          {states.status === 'connected' ? '✅ 已连接' : '❌ 未连接'}
        </span>
        {states.status === 'connected' && (
          <span className="model">模型: {states.model}</span>
        )}
      </div>

      {/* 对话界面 */}
      <div className="chat-interface">
        <div className="messages">
          {messages.map((msg, index) => (
            <div key={index} className={`message ${msg.role}`}>
              <div className="role">{msg.role === 'user' ? '👤' : '🤖'}</div>
              <div className="content">{msg.content}</div>
            </div>
          ))}
          {isLoading && (
            <div className="message assistant loading">
              <div className="role">🤖</div>
              <div className="content">思考中...</div>
            </div>
          )}
        </div>

        <div className="input-area">
          <input
            type="text"
            value={input}
            onChange={(e) => setInput(e.target.value)}
            placeholder="输入你的问题..."
            onKeyPress={(e) => e.key === 'Enter' && handleSendMessage()}
            disabled={isLoading}
          />
          <button 
            onClick={handleSendMessage}
            disabled={!input.trim() || !llmClient || isLoading}
          >
            {isLoading ? '⏳' : '💬'}
          </button>
        </div>
      </div>
    </div>
  );
};
```

## 🎨 样式示例

```css
/* 实例状态指示器样式 */
.instance-status {
  display: flex;
  gap: 12px;
  align-items: center;
  padding: 8px 12px;
  background: #f3f4f6;
  border-radius: 8px;
  margin-bottom: 16px;
  font-size: 14px;
}

.instance-name {
  font-weight: bold;
  color: #374151;
}

.status.connected {
  color: #059669;
}

.status.disconnected {
  color: #dc2626;
}

.model {
  color: #6b7280;
  font-family: monospace;
}

/* 区域分割样式 */
.ai-workspace {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
  gap: 24px;
  padding: 24px;
}

.ai-workspace section {
  border: 2px solid #e5e7eb;
  border-radius: 12px;
  padding: 20px;
}

.summary-area {
  border-color: #3b82f6; /* 蓝色 - 总结 */
}

.chat-area {
  border-color: #10b981; /* 绿色 - 对话 */
}

.translate-area {
  border-color: #f59e0b; /* 橙色 - 翻译 */
}
```

## 📊 优势对比

| 特性 | 无命名管理 | 有命名管理 |
|------|------------|------------|
| **绑定清晰度** | ❌ 不明确 | ✅ 一目了然 |
| **调试难度** | ❌ 困难 | ✅ 简单 |
| **开发体验** | ❌ 容易混乱 | ✅ 直观明确 |
| **代码可读性** | ❌ 需要推测 | ✅ 自文档化 |
| **错误定位** | ❌ 难以排查 | ✅ 快速定位 |

## 🚀 实际使用效果

### 控制台输出示例
```
✅ document-summary 总结完成
✅ intelligent-chat 对话响应完成
❌ multi-translate 翻译失败: API key not configured
```

### DOM 结构示例
```html
<div class="document-summary" data-instance="document-summary">
  <div class="instance-status">
    <span class="instance-name">实例: document-summary</span>
    <span class="status connected">✅ 已连接</span>
    <span class="model">模型: gpt-4o-mini</span>
  </div>
  <!-- 功能UI -->
</div>
```

## 💡 最佳实践

### 1. **命名规范**
```tsx
// 推荐：功能-模式 格式
<LlmConnectorProvider name="summary-economy" />
<LlmConnectorProvider name="chat-premium" />
<LlmConnectorProvider name="translate-multilang" />

// 不推荐：过于简单
<LlmConnectorProvider name="a" />
<LlmConnectorProvider name="b" />
```

### 2. **视觉区分**
```tsx
// 为不同实例使用不同的视觉样式
<div className={`feature-area ${instanceName}-theme`}>
```

### 3. **错误处理**
```tsx
// 在错误信息中包含实例名称
const handleError = (error: Error) => {
  console.error(`❌ [${instanceName}] 操作失败:`, error);
  setError(`${instanceName} 实例发生错误: ${error.message}`);
};
```

## 🎯 总结

通过名字管理不同实例的核心优势：
- ✅ **解决绑定混乱** - 每个组件都清楚知道使用哪个client
- ✅ **提升调试体验** - 错误日志和状态都有明确标识
- ✅ **增强代码可读性** - 实例用途一目了然
- ✅ **降低开发门槛** - 新手也不容易搞错

这就是"通过不同名字来管理不同实例"的完整实现方案！